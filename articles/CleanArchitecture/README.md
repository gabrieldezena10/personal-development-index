# The Clean Architecture

![The Clean architecture](https://github.com/gabrieldezena10/personal-development-index/assets/86879421/2a178c48-5dbe-4c7a-953e-9e0c6b90821c)

Over the last several years we’ve seen a whole range of ideas regarding the architecture of systems. These include:
  - Hexagonal Architecture (a.k.a. Ports and Adapters) by Alistair Cockburn and adopted by Steve Freeman, and Nat Pryce in their wonderful book Growing Object Oriented Software
  - Onion Architecture by Jeffrey Palermo
  - Screaming Architecture from a blog of mine last year
  - DCI from James Coplien, and Trygve Reenskaug.
  - BCE by Ivar Jacobson from his book Object Oriented Software Engineering: A Use-Case Driven Approach

Though these architectures all vary somewhat in their details, they are very similar. They all have the same objective, which is the separation of concerns. Each of these architectures produce systems that are:

1. **Independent of Frameworks**. The architecture does not depend on the existence of some library of feature laden software. This allows you to use such frameworks as tools, rather than having to cram your system into their limited constraints.
2. **Testable**. The business rules can be tested without the UI, Database, Web Server, or any other external element.
3. **Independent of UI**. The UI can change easily, without changing the rest of the system. A Web UI could be replaced with a console UI, for example, without changing the business rules.
4. **Independent of Database**. You can swap out Oracle or SQL Server, for Mongo, BigTable, CouchDB, or something else. Your business rules are not bound to the database.
5. **Independent of any external agency**. In fact your business rules simply don’t know anything at all about the outside world.

## The Dependency Rule
The Dependency Rule is a fundamental principle governing software architecture. It is visualized through concentric circles, each representing different software areas, 
with inner circles denoting higher-level software and outer circles representing mechanisms.

The Dependency Rule states:

- Source code dependencies must only point inwards.
- Inner circles should have no knowledge of anything in outer circles.
- The code in inner circles should not reference anything declared in outer circles, be it functions, classes, variables, or any named software entity.
- Inner circles should avoid using data formats from outer circles, particularly those generated by frameworks in outer circles.
- The goal is to isolate outer circle elements from impacting inner circles.

## Entities
Entities in software architecture encapsulate enterprise-wide business rules. They can take the form of objects with methods or a collection of data structures and functions. 
Their purpose is to serve multiple applications within an enterprise, or if you're building a single application, they function as its core business objects. 
These entities embody the most general and high-level rules and are the least likely to change due to external factors like page navigation or security changes. 
Operational changes in specific applications should not impact the entity layer.

## Use Cases
The software in this layer houses application-specific business rules. It orchestrates the use cases of the system, directing data flow to and from entities and leveraging 
enterprise-wide business rules to achieve use case goals. Changes in this layer should not affect entities, nor should it be affected by external factors like database modifications, 
UI alterations, or common frameworks. However, changes in how the application operates will impact use cases and, consequently, some code in this layer.

## Interface Adapters
This layer consists of adapters responsible for converting data from formats most suitable for use cases and entities to formats convenient for external entities such as databases or 
the web. It encompasses the MVC architecture of a GUI, with Presenters, Views, and Controllers residing here. Models are typically data structures passed between controllers, use cases, 
presenters, and views.

Data conversion also occurs in this layer, transitioning data from the format preferred by entities and use cases to the format required by the chosen persistence framework, 
e.g., a SQL database. Any database-related code should be confined to this layer. Additionally, this layer accommodates adapters necessary for transforming data from external sources, 
such as external services, into the internal format used by use cases and entities.

## Frameworks and Drivers
The outermost layer primarily comprises frameworks and tools, such as the Database and Web Framework. It is characterized by minimal custom code, mainly serving as the bridge 
to the inner layers. In this layer, the nitty-gritty details reside – the web intricacies and database specifics. Keeping these elements external minimizes their impact on the core system.

## Circles in Software Architecture
In software architecture, the use of circles is schematic and not limited to just four. The number of circles can vary as needed, but The Dependency Rule always applies. 
Source code dependencies must always point inwards. As you move inwards, the level of abstraction increases, with the outermost circle representing low-level concrete details, 
and the innermost circle embodying the most general policies.

## Crossing Boundaries
Crossing boundaries between circles is common in software design. For instance, Controllers and Presenters may communicate with Use Cases in the next layer. The flow of control 
typically begins in the controller, passes through the use case, and concludes in the presenter. To resolve this situation without violating The Dependency Rule, the Dependency Inversion 
Principle is often used. This involves structuring interfaces and inheritance relationships to ensure that source code dependencies oppose the flow of control at appropriate points across the boundary.

For example, when a use case needs to call a presenter, it does so indirectly by invoking an interface (e.g., Use Case Output Port) in the inner circle, which is then implemented by 
the presenter in the outer circle. This technique is applied to cross all boundaries in the architecture, utilizing dynamic polymorphism to create source code dependencies that align with
The Dependency Rule, regardless of the direction of control flow.

## Data Crossing Boundaries
Data crossing boundaries typically consists of simple data structures. These can be basic structs, Data Transfer objects, function call arguments, or even packed into a 
hashmap or an object. The key is to keep the data structures isolated and simple, free from any dependencies that would violate The Dependency Rule.

For instance, when passing data across a boundary, it should be in the format most convenient for the inner circle. Avoid passing complex entities or database rows, as this would 
introduce unwanted dependencies and violate the rule.

## Conclusion
Adhering to these principles simplifies software design and enhances testability. By structuring your system into layers and following The Dependency Rule, you create a system that is easier 
to maintain and update. When external components like the database or web framework become obsolete, they can be replaced with minimal disruption.
